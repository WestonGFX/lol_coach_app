const axios = require('axios');
const cheerio = require('cheerio');
const { encodeSpecialCharacters } = require('./utils');

module.exports = (logError, DATA_SOURCES) => {
  async function scrapeMobalytics(summonerName, tagLine, region, retryCount = 0) {
    const maxRetries = 3;
    try {
      const fullName = `${summonerName}-${tagLine}`;
      const encodedName = encodeSpecialCharacters(fullName.toLowerCase());
      const url = `https://mobalytics.gg/lol/profile/${region}/${encodedName}/`;
      console.log(`[Mobalytics] Scraping: ${url}`);
      const response = await axios.get(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9',
          'Referer': 'https://mobalytics.gg/',
          'DNT': '1'
        },
        timeout: 20000,
        validateStatus: status => status < 500
      });

      if (response.status === 404) {
        throw new Error(`Summoner ${summonerName}#${tagLine} not found on Mobalytics`);
      }

      const $ = cheerio.load(response.data);

      // Get summoner level
      const levelEl = $('[class*="level"], [class*="summoner-level"]').first();
      const levelMatch = levelEl.text().match(/\d+/);
      const level = levelMatch ? parseInt(levelMatch[0]) : 0;

      // Get rank info
      const rankEl = $('[class*="rank-tier"], [class*="current-rank"]').first();
      const rankText = rankEl.text().trim();
      const rankMatch = rankText.match(/(Iron|Bronze|Silver|Gold|Platinum|Diamond|Master|Grandmaster|Challenger)\s*(I{1,4}|V?I{0,3})?/i);
      
      let rankedData = null;
      if (rankMatch) {
        const [_, tier, division] = rankMatch;
        const lpEl = rankEl.closest('[class*="rank-container"]').find('[class*="lp"]');
        const lpMatch = lpEl.text().match(/(\d+)/);
        const lp = lpMatch ? parseInt(lpMatch[1]) : 0;

        // Find wins/losses near the rank display
        const statsContainer = rankEl.closest('[class*="rank-container"]');
        const winsMatch = statsContainer.text().match(/(\d+)\s*W/i);
        const lossesMatch = statsContainer.text().match(/(\d+)\s*L/i);
        const wins = winsMatch ? parseInt(winsMatch[1]) : 0;
        const losses = lossesMatch ? parseInt(lossesMatch[1]) : 0;

        rankedData = {
          queueType: 'RANKED_SOLO_5x5',
          tier,
          rank: division || '',
          leaguePoints: lp,
          wins,
          losses
        };
      }

      // Get match history
      const recentMatches = [];
      $('[class*="match-row"], [class*="game-history-row"]').each((_, matchEl) => {
        const $match = $(matchEl);
        
        // Skip if not a regular game mode
        const gameType = $match.find('[class*="queue-type"]').text().trim().toLowerCase();
        if (gameType.includes('arena')) return;

        const champName = $match.find('[class*="champion-name"]').text().trim();
        const kdaEl = $match.find('[class*="kda"]');
        const kdaText = kdaEl.text().trim();
        const kdaMatch = kdaText.match(/(\d+)\s*\/\s*(\d+)\s*\/\s*(\d+)/);
        
        if (kdaMatch) {
          const csText = $match.find('[class*="cs"], [class*="minions"]').text().trim();
          const csMatch = csText.match(/(\d+)/);
          const durationText = $match.find('[class*="duration"]').text().trim();
          const durationMatch = durationText.match(/(\d+):(\d+)/);
          
          let csPerMin = 0;
          if (csMatch && durationMatch) {
            const cs = parseInt(csMatch[1]);
            const minutes = parseInt(durationMatch[1]);
            const seconds = parseInt(durationMatch[2]);
            const duration = minutes + (seconds / 60);
            csPerMin = duration > 0 ? cs / duration : 0;
          }

          const isWin = $match.find('[class*="victory"], [class*="win"]').length > 0;
          
          recentMatches.push({
            champion: champName,
            result: isWin ? 'Victory' : 'Defeat',
            kda: {
              kills: parseInt(kdaMatch[1]),
              deaths: parseInt(kdaMatch[2]),
              assists: parseInt(kdaMatch[3])
            },
            cs: parseInt(csMatch?.[1]) || 0,
            csPerMin: parseFloat(csPerMin.toFixed(1))
          });
        }
      });

      // Calculate overall statistics
      let totalKills = 0, totalDeaths = 0, totalAssists = 0;
      let validGames = 0;
      
      recentMatches.forEach(match => {
        if (match.kda) {
          totalKills += match.kda.kills;
          totalDeaths += match.kda.deaths;
          totalAssists += match.kda.assists;
          validGames++;
        }
      });

      // Calculate proper KDA using League's formula
      const avgKDA = totalDeaths > 0 ? 
        ((totalKills + totalAssists) / totalDeaths).toFixed(2) : 
        (totalKills + totalAssists).toFixed(2);

      // Calculate proper CS/min average
      const avgCS = validGames > 0 ? 
        (recentMatches.reduce((sum, m) => sum + (m.csPerMin || 0), 0) / validGames).toFixed(1) : 
        '0';

      // Calculate win rate from ranked data
      const wins = rankedData ? rankedData.wins : 0;
      const losses = rankedData ? rankedData.losses : 0;
      const totalGames = wins + losses;
      const winRate = totalGames > 0 ? wins / totalGames : 0;

      // Get Mobalytics-specific GPI score
      const gpiEl = $('[class*="gpi-score"], [class*="profile-score"]').first();
      const gpiScore = parseFloat(gpiEl.text()) || 0;

      const summonerData = {
        summoner: {
          name: summonerName,
          tagLine,
          region,
          level
        },
        ranked: rankedData ? [rankedData] : [],
        matches: recentMatches,
        statistics: {
          totalGames,
          winRate,
          avgKDA: parseFloat(avgKDA),
          avgCS: parseFloat(avgCS),
          kda: {
            kills: Math.round(totalKills / validGames) || 0,
            deaths: Math.round(totalDeaths / validGames) || 0,
            assists: Math.round(totalAssists / validGames) || 0
          }
        },
        mobalyticsGPI: gpiScore, // Mobalytics-specific metric
        sourceUrl: url
      };

      console.log(`[Mobalytics] Successfully scraped data for ${summonerName}#${tagLine}`);
      return summonerData;

    } catch (error) {
      logError(DATA_SOURCES.MOBALYTICS, 'SCRAPE_SUMMONER', error, { summonerName, tagLine, region, retryCount });
      if (retryCount < maxRetries && (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT')) {
        console.log(`[Mobalytics] Retrying... (${retryCount + 1}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, 4000 * (retryCount + 1)));
        return scrapeMobalytics(summonerName, tagLine, region, retryCount + 1);
      }
      throw error;
    }
  }

  return { scrapeMobalytics };
};
