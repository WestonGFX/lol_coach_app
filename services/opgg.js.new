const axios = require('axios');
const cheerio = require('cheerio');
const { encodeSpecialCharacters } = require('./utils');

module.exports = (logError, DATA_SOURCES) => {
  async function scrapeOPGG(summonerName, tagLine, region, retryCount = 0) {
    const maxRetries = 3;
    try {
      const fullName = `${summonerName}-${tagLine}`;
      const encodedName = encodeSpecialCharacters(fullName);
      const url = `https://op.gg/lol/summoners/${region}/${encodedName}`;
      console.log(`[OP.GG] Scraping: ${url}`);
      const response = await axios.get(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5'
        },
        timeout: 15000
      });

      if (response.status === 404) {
        throw new Error(`Summoner ${summonerName}#${tagLine} not found on OP.GG`);
      }

      const $ = cheerio.load(response.data);

      // Get summoner level
      const levelText = $('[class*="level"], [class*="summoner-level"]').first().text().trim();
      const level = parseInt(levelText.match(/\d+/)?.[0]) || 0;

      // Get rank info
      let rankedData = null;
      $('[class*="tier-rank"], [class*="tier"], [class*="rank-tier"]').each((_, el) => {
        const tierEl = $(el);
        const rankText = tierEl.text().trim();
        const rankMatch = rankText.match(/(Iron|Bronze|Silver|Gold|Platinum|Diamond|Master|Grandmaster|Challenger)\s*(I{1,4}|V?I{0,3})?/i);
        
        if (rankMatch) {
          const [_, tier, division] = rankMatch;
          const container = tierEl.closest('[class*="wrapper"], [class*="container"]');
          
          // Get LP
          const lpText = container.find('[class*="lp"], [class*="league-points"]').text().trim();
          const lp = parseInt(lpText.match(/\d+/)?.[0]) || 0;
          
          // Get wins/losses
          const winsText = container.find('[class*="win"], [class*="wins"]').text().trim();
          const lossesText = container.find('[class*="loss"], [class*="losses"]').text().trim();
          const wins = parseInt(winsText.match(/\d+/)?.[0]) || 0;
          const losses = parseInt(lossesText.match(/\d+/)?.[0]) || 0;
          
          rankedData = {
            queueType: 'RANKED_SOLO_5x5',
            tier: tier || 'Unranked',
            rank: division || '',
            leaguePoints: lp,
            wins,
            losses
          };
          return false; // Only get the first ranked queue data
        }
      });

      // Get OP Score - unique to OP.GG
      const opScoreEl = $('[class*="op-score"], [class*="rating"]').first();
      const opScore = parseInt(opScoreEl.text().match(/\d+/)?.[0]) || 50;

      // Get match history
      const recentMatches = [];
      $('[class*="game-item"], [class*="match-history-item"]').each((_, matchEl) => {
        const $match = $(matchEl);
        
        // Skip if not a regular game mode
        const gameType = $match.find('[class*="game-type"]').text().trim().toLowerCase();
        if (gameType.includes('arena')) return;
        
        const champion = $match.find('[class*="champion-name"]').text().trim();
        const result = $match.find('[class*="result"]').text().trim();
        const kdaEl = $match.find('[class*="k-d-a"]');
        const kdaText = kdaEl.text().trim();
        const kdaMatch = kdaText.match(/(\d+)\s*\/\s*(\d+)\s*\/\s*(\d+)/);
        
        if (kdaMatch) {
          const csText = $match.find('[class*="cs"], [class*="creep-score"]').text().trim();
          const durationText = $match.find('[class*="game-duration"]').text().trim();
          const csMatch = csText.match(/(\d+)/);
          const durationMatch = durationText.match(/(\d+):(\d+)/);
          
          let csPerMin = 0;
          if (csMatch && durationMatch) {
            const cs = parseInt(csMatch[1]);
            const minutes = parseInt(durationMatch[1]);
            const seconds = parseInt(durationMatch[2]);
            const duration = minutes + (seconds / 60);
            csPerMin = duration > 0 ? cs / duration : 0;
          }
          
          recentMatches.push({
            champion,
            result: result.toLowerCase().includes('victory') ? 'Victory' : 'Defeat',
            kda: {
              kills: parseInt(kdaMatch[1]),
              deaths: parseInt(kdaMatch[2]),
              assists: parseInt(kdaMatch[3])
            },
            cs: parseInt(csMatch?.[1]) || 0,
            csPerMin: parseFloat(csPerMin.toFixed(1))
          });
        }
      });

      // Calculate overall statistics
      let totalKills = 0, totalDeaths = 0, totalAssists = 0, totalCS = 0, totalGames = 0;
      recentMatches.forEach(match => {
        if (match.kda) {
          totalKills += match.kda.kills;
          totalDeaths += match.kda.deaths;
          totalAssists += match.kda.assists;
          totalCS += match.cs;
          totalGames++;
        }
      });

      const avgKDA = totalDeaths > 0 ? 
        ((totalKills + totalAssists) / totalDeaths).toFixed(2) : 
        (totalKills + totalAssists).toFixed(2);

      const avgCS = totalGames > 0 ? 
        (recentMatches.reduce((sum, m) => sum + (m.csPerMin || 0), 0) / totalGames).toFixed(1) : 
        '0';

      // Calculate win rate
      const wins = rankedData ? rankedData.wins : 0;
      const losses = rankedData ? rankedData.losses : 0;
      const totalRankedGames = wins + losses;
      const winRate = totalRankedGames > 0 ? wins / totalRankedGames : 0;

      const summonerData = {
        summoner: {
          name: summonerName,
          tagLine,
          region,
          level
        },
        ranked: rankedData ? [rankedData] : [],
        matches: recentMatches,
        statistics: {
          totalGames: totalRankedGames,
          winRate,
          avgKDA: parseFloat(avgKDA),
          avgCS: parseFloat(avgCS),
          kda: {
            kills: Math.round(totalKills / totalGames),
            deaths: Math.round(totalDeaths / totalGames),
            assists: Math.round(totalAssists / totalGames)
          }
        },
        opScore, // OP.GG specific metric
        sourceUrl: url
      };

      console.log(`[OP.GG] Successfully scraped data for ${summonerName}#${tagLine}`);
      return summonerData;

    } catch (error) {
      logError(DATA_SOURCES.OPGG, 'SCRAPE_SUMMONER', error, { summonerName, tagLine, region, retryCount });
      if (retryCount < maxRetries && (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT')) {
        console.log(`[OP.GG] Retrying... (${retryCount + 1}/${maxRetries})`);
        return scrapeOPGG(summonerName, tagLine, region, retryCount + 1);
      }
      throw error;
    }
  }

  return { scrapeOPGG };
};
